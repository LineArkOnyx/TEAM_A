#include"DxLib.h"
#include"PlayScene.h"
#include"../Character/Character.h"
#include"../Map/Map.h"
#include"../MathPlus/MathPlus.h"
#include"../Scene/Scene.h"
const int SQUARE_Y = 5;		//現在の位置からY軸の当たり判定の範囲を設定する
const int SQUARE_X = 10;	//現在の位置からX軸の当たり判定の範囲を設定する
const int SQUARE_Y_MAX = 27;	//どこまで当たり判定を取るか
const int SQUARE_Y_LOWEST = 1;	//どこまで当たり判定を取るか
PlaySceen playSceen;
void PlaySceen::Character_Hit_Map()
{
	character.StepHitSquare();
	for (int y = character.GetHitSquareY() - SQUARE_Y; character.GetHitSquareY() + SQUARE_Y > y; y++)
	{
		//配列を超えたら
		if (character.GetHitSquareY() > SQUARE_Y_MAX)
			continue;
		//配列を超えたら
		if (character.GetHitSquareY() < SQUARE_Y_LOWEST)
			continue;
		for (int x = character.GetHitSquareX() - SQUARE_X; character.GetHitSquareX() + SQUARE_X > x; x++)
		{
			// ★ここを考える
			// どの方向に進んでいたかチェック
			// ※Playerクラスに進む方向をチェックする関数を準備しています。
			DrawFormatString(0, 48, GetColor(255, 255, 255), "StepHitSquareY=%d", character.GetHitSquareY());
			DrawFormatString(0, 64, GetColor(255, 255, 255), "StepHitSquareX=%d", character.GetHitSquareX());
			bool dirArray[4] = { false,false,false,false };
			character.GetMoveDirection(dirArray);
			// ★ここを考える
			// 矩形の当たり判定用のデータを準備
			// プレイヤーの情報
			int Ax = character.GetPosX();
			int Ay = character.GetPosY();
			int Aw = character.GetW();
			int Ah = character.GetH();

			// オブジェクトの情報
			int Bx = x * 32;
			int By = y * 32;
			int Bw = MAPCHIP_SIZW;
			int Bh = MAPCHIP_SIZH;
			if (MapChipData[y][x] == -1|| MapChipData[y][x] == 40 || MapChipData[y][x] == 41 || MapChipData[y][x] == 46 ||  MapChipData[y][x] == 50 || MapChipData[y][x] == 43 || MapChipData[y][x] == 44 || MapChipData[y][x] == 45 || MapChipData[y][x] == 51 || MapChipData[y][x] == 52 || MapChipData[y][x] == 53 || MapChipData[y][x] == 54 || MapChipData[y][x] == 55 || MapChipData[y][x] == 56 || MapChipData[y][x] == 57 || MapChipData[y][x] == 58)
				continue;
			{
				DrawBox(Bx-character.GetScreenX(), By- character.GetScreenY(), Bx + Bw- character.GetScreenX(), By + Bh- character.GetScreenY(), GetColor(255, 255, 255), false);
				DrawBox(Ax - character.GetScreenX(), Ay - character.GetScreenY(), Ax + Aw - character.GetScreenX(), Ay + Ah - character.GetScreenY(), GetColor(255, 0, 0), false);

				Ay = character.GetPosY();
				Ax = character.GetNextPosX();
				if (Collision::Rect(Ax, Ay, Aw, Ah, Bx, By, Bw, Bh))
				{
					if (dirArray[2]) 
					{
						// ★ここを考える
						// めり込み量を計算する
						int overlap = Bx + Bw - Ax;
						character.SetNextPosX(Ax + overlap);
					}
					// 右方向の修正
					//マリオの右側
					if (dirArray[3]) 
					{
						// ★ここを考える
						// めり込み量を計算する
						int overlap = Ax + Aw - Bx;
						character.SetNextPosX(Ax - overlap);
					}
				}
			}

		}
	}
	for (int y = character.GetHitSquareY() - SQUARE_Y; character.GetHitSquareY() + SQUARE_Y > y; y++)
	{
		//配列を超えたら
		if (character.GetHitSquareY() > SQUARE_Y_MAX)
			continue;
		//配列を超えたら
		if (character.GetHitSquareY() < SQUARE_Y_LOWEST)
			continue;
		for (int x = character.GetHitSquareX() - SQUARE_X; character.GetHitSquareX() + SQUARE_X > x; x++)
		{
			// ★ここを考える
				// どの方向に進んでいたかチェック
				// ※Playerクラスに進む方向をチェックする関数を準備しています。

			bool dirArray[4] = { false,false,false,false };
			character.GetMoveDirection(dirArray);
			// ★ここを考える
			// 矩形の当たり判定用のデータを準備
			// プレイヤーの情報
			int Ax = character.GetPosX();
			int Ay = character.GetPosY();
			int Aw = character.GetW();
			int Ah = character.GetH();

			// オブジェクトの情報
			int Bx = x * 32;
			int By = y * 32;
			int Bw = MAPCHIP_SIZW;
			int Bh = MAPCHIP_SIZH;

			if (MapChipData[y][x] == -1 || MapChipData[y][x] == 46 || MapChipData[y][x] == 41|| MapChipData[y][x] == 40 || MapChipData[y][x] == 50|| MapChipData[y][x] == 43 || MapChipData[y][x] == 44 || MapChipData[y][x] == 45 || MapChipData[y][x] == 51 || MapChipData[y][x] == 52 || MapChipData[y][x] == 53 || MapChipData[y][x] == 54 || MapChipData[y][x] == 55 || MapChipData[y][x] == 56 || MapChipData[y][x] == 57 || MapChipData[y][x] == 58)
				continue;
			{
				Ay = character.GetNextPosY();
				Ax = character.GetNextPosX();
				if (Collision::Rect(Ax, Ay, Aw, Ah, Bx, By, Bw, Bh))
				{
					if (dirArray[0]) {
						// ★ここを考える
						// めり込み量を計算する
						character.SetGravitySpeed(0.0);
						int overlap = By + Bh - Ay;
						character.SetNextPosY((Ay + overlap));
						if (MapChipData[y][x] == 47 || MapChipData[y][x] == 48 || MapChipData[y][x] == 49)
						{
							character.UpConveyorPower();
						}
						if (MapChipData[y][x] == 6)
						{
							MapChipData[y][x] = -1;
						}
					}
					// 右方向の修正
					//マリオの右側
					if (dirArray[1]) 
					{
						if (character.GetStatus() == PL_JUMP)
						{
							character.SetStatus(PL_NORMAL);
						}
						// ★ここを考える
						// めり込み量を計算する
						character.SetJunpFrag();	//着地したらジャンプできるようにする
						character.Junp();			//着地してないとジャンプできない
						character.SetUpJunpTrapFrag(true);	//床に着地していればジャンプ台を起動できる
						int overlap = Ay + Ah - By;
						character.SetNextPosY(Ay - overlap);
						//ベルトコンベアーの当たり判定
						if (MapChipData[y][x] == 47 || MapChipData[y][x] == 48 || MapChipData[y][x] == 49)
						{
							character.UnderConveyorPower();
						}

						
					}
				}
			}
		}
	}
	for (int y = character.GetHitSquareY() - SQUARE_Y; character.GetHitSquareY() + SQUARE_Y > y; y++)
	{
		//配列を超えたら
		if (character.GetHitSquareY() > SQUARE_Y_MAX)
			continue;
		//配列を超えたら
		if (character.GetHitSquareY() < SQUARE_Y_LOWEST)
			continue;
		for (int x = character.GetHitSquareX() - SQUARE_X; character.GetHitSquareX() + SQUARE_X > x; x++)
		{
			
			// ★ここを考える
			// 矩形の当たり判定用のデータを準備
			// プレイヤーの情報

			int Ax = character.GetPosX();
			int Ay = character.GetPosY();
			int Aw = character.GetW();
			int Ah = character.GetH();

			// オブジェクトの情報
			int Bx = x * 32;
			int By = y * 32;
			int Bw = MAPCHIP_SIZW;
			int Bh = MAPCHIP_SIZH;
			bool dirArray[4] = { false,false,false,false };
			character.GetMoveDirection(dirArray);
			if (MapChipData[y][x] == -1)
				continue; 

			DrawBox(Bx - character.GetScreenX(), By - character.GetScreenY(), Bx + Bw - character.GetScreenX(), By + Bh - character.GetScreenY(), GetColor(255, 0, 255), false);
			if (Collision::Rect(Ax, Ay, Aw, Ah, Bx, By, Bw, Bh))
			{
				//はしごの当たり判定
				if (MapChipData[y][x] == 46)
				{	
					//梯子オンフラグを真に
					character.SetladderActiv(true);
				}
				//ばねの当たり判定
				if (MapChipData[y][x] == 41)
				{
					character.UpJunpTrap();
				}
				//ゴールの当たり判定
				if (MapChipData[y][x] == 40 || MapChipData[y][x] == 50)
				{
					g_CurrentSceneID = SCENE_ID_INIT_RESULT;
				}
				//トラップ処理
				if (MapChipData[y][x] == 43|| MapChipData[y][x] == 44|| MapChipData[y][x] == 45)
				{
					DrawFormatString(0, 180, GetColor(255, 255, 255), "トラップヒット");
					g_CurrentSceneID = SCENE_ID_INIT_RESULT;
				}
				if (MapChipData[y][x] == 58)
				{
					MapChipData[y][x] = -1;
				}
			}
			
		}
	}
}
void PlaySceen::Step()
{
	Character_Hit_Map();
}